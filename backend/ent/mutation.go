// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/save-a-gain/app/ent/employee"
	"github.com/save-a-gain/app/ent/repairinvoice"
	"github.com/save-a-gain/app/ent/returninvoice"
	"github.com/save-a-gain/app/ent/statust"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeEmployee      = "Employee"
	TypeRepairinvoice = "Repairinvoice"
	TypeReturninvoice = "Returninvoice"
	TypeStatust       = "Statust"
)

// EmployeeMutation represents an operation that mutate the Employees
// nodes in the graph.
type EmployeeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	employeename     *string
	employeeemail    *string
	password         *string
	clearedFields    map[string]struct{}
	employees        map[int]struct{}
	removedemployees map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Employee, error)
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows to manage the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for $n.Name.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the id field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmployeename sets the employeename field.
func (m *EmployeeMutation) SetEmployeename(s string) {
	m.employeename = &s
}

// Employeename returns the employeename value in the mutation.
func (m *EmployeeMutation) Employeename() (r string, exists bool) {
	v := m.employeename
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeename returns the old employeename value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmployeename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmployeename is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmployeename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeename: %w", err)
	}
	return oldValue.Employeename, nil
}

// ResetEmployeename reset all changes of the "employeename" field.
func (m *EmployeeMutation) ResetEmployeename() {
	m.employeename = nil
}

// SetEmployeeemail sets the employeeemail field.
func (m *EmployeeMutation) SetEmployeeemail(s string) {
	m.employeeemail = &s
}

// Employeeemail returns the employeeemail value in the mutation.
func (m *EmployeeMutation) Employeeemail() (r string, exists bool) {
	v := m.employeeemail
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeemail returns the old employeeemail value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmployeeemail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmployeeemail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmployeeemail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeemail: %w", err)
	}
	return oldValue.Employeeemail, nil
}

// ResetEmployeeemail reset all changes of the "employeeemail" field.
func (m *EmployeeMutation) ResetEmployeeemail() {
	m.employeeemail = nil
}

// SetPassword sets the password field.
func (m *EmployeeMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *EmployeeMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *EmployeeMutation) ResetPassword() {
	m.password = nil
}

// AddEmployeeIDs adds the employees edge to Returninvoice by ids.
func (m *EmployeeMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// RemoveEmployeeIDs removes the employees edge to Returninvoice by ids.
func (m *EmployeeMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed ids of employees.
func (m *EmployeeMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the employees ids in the mutation.
func (m *EmployeeMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees reset all changes of the "employees" edge.
func (m *EmployeeMutation) ResetEmployees() {
	m.employees = nil
	m.removedemployees = nil
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.employeename != nil {
		fields = append(fields, employee.FieldEmployeename)
	}
	if m.employeeemail != nil {
		fields = append(fields, employee.FieldEmployeeemail)
	}
	if m.password != nil {
		fields = append(fields, employee.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldEmployeename:
		return m.Employeename()
	case employee.FieldEmployeeemail:
		return m.Employeeemail()
	case employee.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldEmployeename:
		return m.OldEmployeename(ctx)
	case employee.FieldEmployeeemail:
		return m.OldEmployeeemail(ctx)
	case employee.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldEmployeename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeename(v)
		return nil
	case employee.FieldEmployeeemail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeemail(v)
		return nil
	case employee.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldEmployeename:
		m.ResetEmployeename()
		return nil
	case employee.FieldEmployeeemail:
		m.ResetEmployeeemail()
		return nil
	case employee.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employees != nil {
		edges = append(edges, employee.EdgeEmployees)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedemployees != nil {
		edges = append(edges, employee.EdgeEmployees)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeEmployees:
		m.ResetEmployees()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// RepairinvoiceMutation represents an operation that mutate the Repairinvoices
// nodes in the graph.
type RepairinvoiceMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	symptomid             *int
	addsymptomid          *int
	deviceid              *int
	adddeviceid           *int
	userid                *int
	adduserid             *int
	statusrepairid        *int
	addstatusrepairid     *int
	clearedFields         map[string]struct{}
	repairinvoices        *int
	clearedrepairinvoices bool
	done                  bool
	oldValue              func(context.Context) (*Repairinvoice, error)
}

var _ ent.Mutation = (*RepairinvoiceMutation)(nil)

// repairinvoiceOption allows to manage the mutation configuration using functional options.
type repairinvoiceOption func(*RepairinvoiceMutation)

// newRepairinvoiceMutation creates new mutation for $n.Name.
func newRepairinvoiceMutation(c config, op Op, opts ...repairinvoiceOption) *RepairinvoiceMutation {
	m := &RepairinvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeRepairinvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepairinvoiceID sets the id field of the mutation.
func withRepairinvoiceID(id int) repairinvoiceOption {
	return func(m *RepairinvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Repairinvoice
		)
		m.oldValue = func(ctx context.Context) (*Repairinvoice, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repairinvoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepairinvoice sets the old Repairinvoice of the mutation.
func withRepairinvoice(node *Repairinvoice) repairinvoiceOption {
	return func(m *RepairinvoiceMutation) {
		m.oldValue = func(context.Context) (*Repairinvoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepairinvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepairinvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RepairinvoiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSymptomid sets the symptomid field.
func (m *RepairinvoiceMutation) SetSymptomid(i int) {
	m.symptomid = &i
	m.addsymptomid = nil
}

// Symptomid returns the symptomid value in the mutation.
func (m *RepairinvoiceMutation) Symptomid() (r int, exists bool) {
	v := m.symptomid
	if v == nil {
		return
	}
	return *v, true
}

// OldSymptomid returns the old symptomid value of the Repairinvoice.
// If the Repairinvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RepairinvoiceMutation) OldSymptomid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSymptomid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSymptomid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymptomid: %w", err)
	}
	return oldValue.Symptomid, nil
}

// AddSymptomid adds i to symptomid.
func (m *RepairinvoiceMutation) AddSymptomid(i int) {
	if m.addsymptomid != nil {
		*m.addsymptomid += i
	} else {
		m.addsymptomid = &i
	}
}

// AddedSymptomid returns the value that was added to the symptomid field in this mutation.
func (m *RepairinvoiceMutation) AddedSymptomid() (r int, exists bool) {
	v := m.addsymptomid
	if v == nil {
		return
	}
	return *v, true
}

// ResetSymptomid reset all changes of the "symptomid" field.
func (m *RepairinvoiceMutation) ResetSymptomid() {
	m.symptomid = nil
	m.addsymptomid = nil
}

// SetDeviceid sets the deviceid field.
func (m *RepairinvoiceMutation) SetDeviceid(i int) {
	m.deviceid = &i
	m.adddeviceid = nil
}

// Deviceid returns the deviceid value in the mutation.
func (m *RepairinvoiceMutation) Deviceid() (r int, exists bool) {
	v := m.deviceid
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceid returns the old deviceid value of the Repairinvoice.
// If the Repairinvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RepairinvoiceMutation) OldDeviceid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceid: %w", err)
	}
	return oldValue.Deviceid, nil
}

// AddDeviceid adds i to deviceid.
func (m *RepairinvoiceMutation) AddDeviceid(i int) {
	if m.adddeviceid != nil {
		*m.adddeviceid += i
	} else {
		m.adddeviceid = &i
	}
}

// AddedDeviceid returns the value that was added to the deviceid field in this mutation.
func (m *RepairinvoiceMutation) AddedDeviceid() (r int, exists bool) {
	v := m.adddeviceid
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceid reset all changes of the "deviceid" field.
func (m *RepairinvoiceMutation) ResetDeviceid() {
	m.deviceid = nil
	m.adddeviceid = nil
}

// SetUserid sets the userid field.
func (m *RepairinvoiceMutation) SetUserid(i int) {
	m.userid = &i
	m.adduserid = nil
}

// Userid returns the userid value in the mutation.
func (m *RepairinvoiceMutation) Userid() (r int, exists bool) {
	v := m.userid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserid returns the old userid value of the Repairinvoice.
// If the Repairinvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RepairinvoiceMutation) OldUserid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserid: %w", err)
	}
	return oldValue.Userid, nil
}

// AddUserid adds i to userid.
func (m *RepairinvoiceMutation) AddUserid(i int) {
	if m.adduserid != nil {
		*m.adduserid += i
	} else {
		m.adduserid = &i
	}
}

// AddedUserid returns the value that was added to the userid field in this mutation.
func (m *RepairinvoiceMutation) AddedUserid() (r int, exists bool) {
	v := m.adduserid
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserid reset all changes of the "userid" field.
func (m *RepairinvoiceMutation) ResetUserid() {
	m.userid = nil
	m.adduserid = nil
}

// SetStatusrepairid sets the statusrepairid field.
func (m *RepairinvoiceMutation) SetStatusrepairid(i int) {
	m.statusrepairid = &i
	m.addstatusrepairid = nil
}

// Statusrepairid returns the statusrepairid value in the mutation.
func (m *RepairinvoiceMutation) Statusrepairid() (r int, exists bool) {
	v := m.statusrepairid
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusrepairid returns the old statusrepairid value of the Repairinvoice.
// If the Repairinvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RepairinvoiceMutation) OldStatusrepairid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusrepairid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusrepairid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusrepairid: %w", err)
	}
	return oldValue.Statusrepairid, nil
}

// AddStatusrepairid adds i to statusrepairid.
func (m *RepairinvoiceMutation) AddStatusrepairid(i int) {
	if m.addstatusrepairid != nil {
		*m.addstatusrepairid += i
	} else {
		m.addstatusrepairid = &i
	}
}

// AddedStatusrepairid returns the value that was added to the statusrepairid field in this mutation.
func (m *RepairinvoiceMutation) AddedStatusrepairid() (r int, exists bool) {
	v := m.addstatusrepairid
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatusrepairid reset all changes of the "statusrepairid" field.
func (m *RepairinvoiceMutation) ResetStatusrepairid() {
	m.statusrepairid = nil
	m.addstatusrepairid = nil
}

// SetRepairinvoicesID sets the repairinvoices edge to Returninvoice by id.
func (m *RepairinvoiceMutation) SetRepairinvoicesID(id int) {
	m.repairinvoices = &id
}

// ClearRepairinvoices clears the repairinvoices edge to Returninvoice.
func (m *RepairinvoiceMutation) ClearRepairinvoices() {
	m.clearedrepairinvoices = true
}

// RepairinvoicesCleared returns if the edge repairinvoices was cleared.
func (m *RepairinvoiceMutation) RepairinvoicesCleared() bool {
	return m.clearedrepairinvoices
}

// RepairinvoicesID returns the repairinvoices id in the mutation.
func (m *RepairinvoiceMutation) RepairinvoicesID() (id int, exists bool) {
	if m.repairinvoices != nil {
		return *m.repairinvoices, true
	}
	return
}

// RepairinvoicesIDs returns the repairinvoices ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RepairinvoicesID instead. It exists only for internal usage by the builders.
func (m *RepairinvoiceMutation) RepairinvoicesIDs() (ids []int) {
	if id := m.repairinvoices; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepairinvoices reset all changes of the "repairinvoices" edge.
func (m *RepairinvoiceMutation) ResetRepairinvoices() {
	m.repairinvoices = nil
	m.clearedrepairinvoices = false
}

// Op returns the operation name.
func (m *RepairinvoiceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Repairinvoice).
func (m *RepairinvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RepairinvoiceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.symptomid != nil {
		fields = append(fields, repairinvoice.FieldSymptomid)
	}
	if m.deviceid != nil {
		fields = append(fields, repairinvoice.FieldDeviceid)
	}
	if m.userid != nil {
		fields = append(fields, repairinvoice.FieldUserid)
	}
	if m.statusrepairid != nil {
		fields = append(fields, repairinvoice.FieldStatusrepairid)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RepairinvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repairinvoice.FieldSymptomid:
		return m.Symptomid()
	case repairinvoice.FieldDeviceid:
		return m.Deviceid()
	case repairinvoice.FieldUserid:
		return m.Userid()
	case repairinvoice.FieldStatusrepairid:
		return m.Statusrepairid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RepairinvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repairinvoice.FieldSymptomid:
		return m.OldSymptomid(ctx)
	case repairinvoice.FieldDeviceid:
		return m.OldDeviceid(ctx)
	case repairinvoice.FieldUserid:
		return m.OldUserid(ctx)
	case repairinvoice.FieldStatusrepairid:
		return m.OldStatusrepairid(ctx)
	}
	return nil, fmt.Errorf("unknown Repairinvoice field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RepairinvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repairinvoice.FieldSymptomid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymptomid(v)
		return nil
	case repairinvoice.FieldDeviceid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceid(v)
		return nil
	case repairinvoice.FieldUserid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserid(v)
		return nil
	case repairinvoice.FieldStatusrepairid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusrepairid(v)
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RepairinvoiceMutation) AddedFields() []string {
	var fields []string
	if m.addsymptomid != nil {
		fields = append(fields, repairinvoice.FieldSymptomid)
	}
	if m.adddeviceid != nil {
		fields = append(fields, repairinvoice.FieldDeviceid)
	}
	if m.adduserid != nil {
		fields = append(fields, repairinvoice.FieldUserid)
	}
	if m.addstatusrepairid != nil {
		fields = append(fields, repairinvoice.FieldStatusrepairid)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RepairinvoiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case repairinvoice.FieldSymptomid:
		return m.AddedSymptomid()
	case repairinvoice.FieldDeviceid:
		return m.AddedDeviceid()
	case repairinvoice.FieldUserid:
		return m.AddedUserid()
	case repairinvoice.FieldStatusrepairid:
		return m.AddedStatusrepairid()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RepairinvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case repairinvoice.FieldSymptomid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSymptomid(v)
		return nil
	case repairinvoice.FieldDeviceid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceid(v)
		return nil
	case repairinvoice.FieldUserid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserid(v)
		return nil
	case repairinvoice.FieldStatusrepairid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusrepairid(v)
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RepairinvoiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RepairinvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepairinvoiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Repairinvoice nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RepairinvoiceMutation) ResetField(name string) error {
	switch name {
	case repairinvoice.FieldSymptomid:
		m.ResetSymptomid()
		return nil
	case repairinvoice.FieldDeviceid:
		m.ResetDeviceid()
		return nil
	case repairinvoice.FieldUserid:
		m.ResetUserid()
		return nil
	case repairinvoice.FieldStatusrepairid:
		m.ResetStatusrepairid()
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RepairinvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.repairinvoices != nil {
		edges = append(edges, repairinvoice.EdgeRepairinvoices)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RepairinvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repairinvoice.EdgeRepairinvoices:
		if id := m.repairinvoices; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RepairinvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RepairinvoiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RepairinvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrepairinvoices {
		edges = append(edges, repairinvoice.EdgeRepairinvoices)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RepairinvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case repairinvoice.EdgeRepairinvoices:
		return m.clearedrepairinvoices
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RepairinvoiceMutation) ClearEdge(name string) error {
	switch name {
	case repairinvoice.EdgeRepairinvoices:
		m.ClearRepairinvoices()
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RepairinvoiceMutation) ResetEdge(name string) error {
	switch name {
	case repairinvoice.EdgeRepairinvoices:
		m.ResetRepairinvoices()
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice edge %s", name)
}

// ReturninvoiceMutation represents an operation that mutate the Returninvoices
// nodes in the graph.
type ReturninvoiceMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	addedtime             *time.Time
	clearedFields         map[string]struct{}
	_Repairinvoice        *int
	cleared_Repairinvoice bool
	_Employee             *int
	cleared_Employee      bool
	_Statust              *int
	cleared_Statust       bool
	done                  bool
	oldValue              func(context.Context) (*Returninvoice, error)
}

var _ ent.Mutation = (*ReturninvoiceMutation)(nil)

// returninvoiceOption allows to manage the mutation configuration using functional options.
type returninvoiceOption func(*ReturninvoiceMutation)

// newReturninvoiceMutation creates new mutation for $n.Name.
func newReturninvoiceMutation(c config, op Op, opts ...returninvoiceOption) *ReturninvoiceMutation {
	m := &ReturninvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeReturninvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReturninvoiceID sets the id field of the mutation.
func withReturninvoiceID(id int) returninvoiceOption {
	return func(m *ReturninvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Returninvoice
		)
		m.oldValue = func(ctx context.Context) (*Returninvoice, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Returninvoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReturninvoice sets the old Returninvoice of the mutation.
func withReturninvoice(node *Returninvoice) returninvoiceOption {
	return func(m *ReturninvoiceMutation) {
		m.oldValue = func(context.Context) (*Returninvoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReturninvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReturninvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ReturninvoiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddedtime sets the addedtime field.
func (m *ReturninvoiceMutation) SetAddedtime(t time.Time) {
	m.addedtime = &t
}

// Addedtime returns the addedtime value in the mutation.
func (m *ReturninvoiceMutation) Addedtime() (r time.Time, exists bool) {
	v := m.addedtime
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedtime returns the old addedtime value of the Returninvoice.
// If the Returninvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReturninvoiceMutation) OldAddedtime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedtime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedtime: %w", err)
	}
	return oldValue.Addedtime, nil
}

// ResetAddedtime reset all changes of the "addedtime" field.
func (m *ReturninvoiceMutation) ResetAddedtime() {
	m.addedtime = nil
}

// SetRepairinvoiceID sets the Repairinvoice edge to Repairinvoice by id.
func (m *ReturninvoiceMutation) SetRepairinvoiceID(id int) {
	m._Repairinvoice = &id
}

// ClearRepairinvoice clears the Repairinvoice edge to Repairinvoice.
func (m *ReturninvoiceMutation) ClearRepairinvoice() {
	m.cleared_Repairinvoice = true
}

// RepairinvoiceCleared returns if the edge Repairinvoice was cleared.
func (m *ReturninvoiceMutation) RepairinvoiceCleared() bool {
	return m.cleared_Repairinvoice
}

// RepairinvoiceID returns the Repairinvoice id in the mutation.
func (m *ReturninvoiceMutation) RepairinvoiceID() (id int, exists bool) {
	if m._Repairinvoice != nil {
		return *m._Repairinvoice, true
	}
	return
}

// RepairinvoiceIDs returns the Repairinvoice ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RepairinvoiceID instead. It exists only for internal usage by the builders.
func (m *ReturninvoiceMutation) RepairinvoiceIDs() (ids []int) {
	if id := m._Repairinvoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepairinvoice reset all changes of the "Repairinvoice" edge.
func (m *ReturninvoiceMutation) ResetRepairinvoice() {
	m._Repairinvoice = nil
	m.cleared_Repairinvoice = false
}

// SetEmployeeID sets the Employee edge to Employee by id.
func (m *ReturninvoiceMutation) SetEmployeeID(id int) {
	m._Employee = &id
}

// ClearEmployee clears the Employee edge to Employee.
func (m *ReturninvoiceMutation) ClearEmployee() {
	m.cleared_Employee = true
}

// EmployeeCleared returns if the edge Employee was cleared.
func (m *ReturninvoiceMutation) EmployeeCleared() bool {
	return m.cleared_Employee
}

// EmployeeID returns the Employee id in the mutation.
func (m *ReturninvoiceMutation) EmployeeID() (id int, exists bool) {
	if m._Employee != nil {
		return *m._Employee, true
	}
	return
}

// EmployeeIDs returns the Employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *ReturninvoiceMutation) EmployeeIDs() (ids []int) {
	if id := m._Employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "Employee" edge.
func (m *ReturninvoiceMutation) ResetEmployee() {
	m._Employee = nil
	m.cleared_Employee = false
}

// SetStatustID sets the Statust edge to Statust by id.
func (m *ReturninvoiceMutation) SetStatustID(id int) {
	m._Statust = &id
}

// ClearStatust clears the Statust edge to Statust.
func (m *ReturninvoiceMutation) ClearStatust() {
	m.cleared_Statust = true
}

// StatustCleared returns if the edge Statust was cleared.
func (m *ReturninvoiceMutation) StatustCleared() bool {
	return m.cleared_Statust
}

// StatustID returns the Statust id in the mutation.
func (m *ReturninvoiceMutation) StatustID() (id int, exists bool) {
	if m._Statust != nil {
		return *m._Statust, true
	}
	return
}

// StatustIDs returns the Statust ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StatustID instead. It exists only for internal usage by the builders.
func (m *ReturninvoiceMutation) StatustIDs() (ids []int) {
	if id := m._Statust; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatust reset all changes of the "Statust" edge.
func (m *ReturninvoiceMutation) ResetStatust() {
	m._Statust = nil
	m.cleared_Statust = false
}

// Op returns the operation name.
func (m *ReturninvoiceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Returninvoice).
func (m *ReturninvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ReturninvoiceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.addedtime != nil {
		fields = append(fields, returninvoice.FieldAddedtime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ReturninvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case returninvoice.FieldAddedtime:
		return m.Addedtime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ReturninvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case returninvoice.FieldAddedtime:
		return m.OldAddedtime(ctx)
	}
	return nil, fmt.Errorf("unknown Returninvoice field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReturninvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case returninvoice.FieldAddedtime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedtime(v)
		return nil
	}
	return fmt.Errorf("unknown Returninvoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ReturninvoiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ReturninvoiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReturninvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Returninvoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ReturninvoiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ReturninvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReturninvoiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Returninvoice nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ReturninvoiceMutation) ResetField(name string) error {
	switch name {
	case returninvoice.FieldAddedtime:
		m.ResetAddedtime()
		return nil
	}
	return fmt.Errorf("unknown Returninvoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ReturninvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Repairinvoice != nil {
		edges = append(edges, returninvoice.EdgeRepairinvoice)
	}
	if m._Employee != nil {
		edges = append(edges, returninvoice.EdgeEmployee)
	}
	if m._Statust != nil {
		edges = append(edges, returninvoice.EdgeStatust)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ReturninvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case returninvoice.EdgeRepairinvoice:
		if id := m._Repairinvoice; id != nil {
			return []ent.Value{*id}
		}
	case returninvoice.EdgeEmployee:
		if id := m._Employee; id != nil {
			return []ent.Value{*id}
		}
	case returninvoice.EdgeStatust:
		if id := m._Statust; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ReturninvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ReturninvoiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ReturninvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Repairinvoice {
		edges = append(edges, returninvoice.EdgeRepairinvoice)
	}
	if m.cleared_Employee {
		edges = append(edges, returninvoice.EdgeEmployee)
	}
	if m.cleared_Statust {
		edges = append(edges, returninvoice.EdgeStatust)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ReturninvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case returninvoice.EdgeRepairinvoice:
		return m.cleared_Repairinvoice
	case returninvoice.EdgeEmployee:
		return m.cleared_Employee
	case returninvoice.EdgeStatust:
		return m.cleared_Statust
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ReturninvoiceMutation) ClearEdge(name string) error {
	switch name {
	case returninvoice.EdgeRepairinvoice:
		m.ClearRepairinvoice()
		return nil
	case returninvoice.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case returninvoice.EdgeStatust:
		m.ClearStatust()
		return nil
	}
	return fmt.Errorf("unknown Returninvoice unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ReturninvoiceMutation) ResetEdge(name string) error {
	switch name {
	case returninvoice.EdgeRepairinvoice:
		m.ResetRepairinvoice()
		return nil
	case returninvoice.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case returninvoice.EdgeStatust:
		m.ResetStatust()
		return nil
	}
	return fmt.Errorf("unknown Returninvoice edge %s", name)
}

// StatustMutation represents an operation that mutate the Statusts
// nodes in the graph.
type StatustMutation struct {
	config
	op              Op
	typ             string
	id              *int
	statustname     *string
	clearedFields   map[string]struct{}
	statusts        map[int]struct{}
	removedstatusts map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Statust, error)
}

var _ ent.Mutation = (*StatustMutation)(nil)

// statustOption allows to manage the mutation configuration using functional options.
type statustOption func(*StatustMutation)

// newStatustMutation creates new mutation for $n.Name.
func newStatustMutation(c config, op Op, opts ...statustOption) *StatustMutation {
	m := &StatustMutation{
		config:        c,
		op:            op,
		typ:           TypeStatust,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatustID sets the id field of the mutation.
func withStatustID(id int) statustOption {
	return func(m *StatustMutation) {
		var (
			err   error
			once  sync.Once
			value *Statust
		)
		m.oldValue = func(ctx context.Context) (*Statust, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Statust.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatust sets the old Statust of the mutation.
func withStatust(node *Statust) statustOption {
	return func(m *StatustMutation) {
		m.oldValue = func(context.Context) (*Statust, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatustMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatustMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StatustMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatustname sets the statustname field.
func (m *StatustMutation) SetStatustname(s string) {
	m.statustname = &s
}

// Statustname returns the statustname value in the mutation.
func (m *StatustMutation) Statustname() (r string, exists bool) {
	v := m.statustname
	if v == nil {
		return
	}
	return *v, true
}

// OldStatustname returns the old statustname value of the Statust.
// If the Statust object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StatustMutation) OldStatustname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatustname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatustname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatustname: %w", err)
	}
	return oldValue.Statustname, nil
}

// ResetStatustname reset all changes of the "statustname" field.
func (m *StatustMutation) ResetStatustname() {
	m.statustname = nil
}

// AddStatustIDs adds the statusts edge to Returninvoice by ids.
func (m *StatustMutation) AddStatustIDs(ids ...int) {
	if m.statusts == nil {
		m.statusts = make(map[int]struct{})
	}
	for i := range ids {
		m.statusts[ids[i]] = struct{}{}
	}
}

// RemoveStatustIDs removes the statusts edge to Returninvoice by ids.
func (m *StatustMutation) RemoveStatustIDs(ids ...int) {
	if m.removedstatusts == nil {
		m.removedstatusts = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstatusts[ids[i]] = struct{}{}
	}
}

// RemovedStatusts returns the removed ids of statusts.
func (m *StatustMutation) RemovedStatustsIDs() (ids []int) {
	for id := range m.removedstatusts {
		ids = append(ids, id)
	}
	return
}

// StatustsIDs returns the statusts ids in the mutation.
func (m *StatustMutation) StatustsIDs() (ids []int) {
	for id := range m.statusts {
		ids = append(ids, id)
	}
	return
}

// ResetStatusts reset all changes of the "statusts" edge.
func (m *StatustMutation) ResetStatusts() {
	m.statusts = nil
	m.removedstatusts = nil
}

// Op returns the operation name.
func (m *StatustMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Statust).
func (m *StatustMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StatustMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.statustname != nil {
		fields = append(fields, statust.FieldStatustname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StatustMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statust.FieldStatustname:
		return m.Statustname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StatustMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statust.FieldStatustname:
		return m.OldStatustname(ctx)
	}
	return nil, fmt.Errorf("unknown Statust field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatustMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statust.FieldStatustname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatustname(v)
		return nil
	}
	return fmt.Errorf("unknown Statust field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StatustMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StatustMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatustMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Statust numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StatustMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StatustMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatustMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Statust nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StatustMutation) ResetField(name string) error {
	switch name {
	case statust.FieldStatustname:
		m.ResetStatustname()
		return nil
	}
	return fmt.Errorf("unknown Statust field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StatustMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.statusts != nil {
		edges = append(edges, statust.EdgeStatusts)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StatustMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statust.EdgeStatusts:
		ids := make([]ent.Value, 0, len(m.statusts))
		for id := range m.statusts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StatustMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstatusts != nil {
		edges = append(edges, statust.EdgeStatusts)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StatustMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case statust.EdgeStatusts:
		ids := make([]ent.Value, 0, len(m.removedstatusts))
		for id := range m.removedstatusts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StatustMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StatustMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StatustMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Statust unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StatustMutation) ResetEdge(name string) error {
	switch name {
	case statust.EdgeStatusts:
		m.ResetStatusts()
		return nil
	}
	return fmt.Errorf("unknown Statust edge %s", name)
}
